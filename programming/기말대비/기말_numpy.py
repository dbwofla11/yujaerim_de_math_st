import numpy as np 

a = np.array([1,2,3])
print(type(a) , a.shape) # .shape는 행과 열(가로줄의 갯수 , 세로줄의 갯수)를 반환함 

b = np.array([[1,2,3],[4,5,6]]) # 이러면 .shape를 하면 2 x 3 이니 (2,3) 이 반환되겠지?


# 행과 열을 이용해서 행렬의 요소반환 가능 (아래와 예시와 같이)
print(b[0,0] , b[0,1] ,b[1,2])  # 반환 1 , 2 , 6 

c = np.zeros((3,3)) # 3 x 3 짜리 '빈' 행렬을 만듬  # 초기화 

# 모든것을 같은 수로 채우는 함수 .full
d = np.full((2,2) , 7) # 2 x 2 행렬을 7로 채움  # 초기화 


e = np.eye(2) # 2 x 2 정사각형 모양의 대칭 행렬을 만듬 -> 행과 열이 서로 바뀌어도 똑같은 행렬이 대칭행렬이라 함 


# a[0,0] , a[1,1] , a[2,0]
#위의것을 a[[0,1,2],[0,1,0]] 으로 한번에 뽑을 수 있다 . 


# f = [1,2,3,4,5,6,7,8,9,0] # 얘는 그냥 리스트

f = np.array([1,2,3,4,5,6,7,8,9,0]) # 꼭 numpy를 쓸때 리스트를 쓰지말고 np.array로 행렬을 만들어서 쓰도록 하자

print(f[np.arange(5)]) # f를 arange함수를 이용해서 재정의 
# arange를 쓰면 arange 길이 만큼 잘라서 배열을 재정의함 
# arange를 쓸때 그냥 리스트면 작동을 안하고 np계열의 array만 작동이 됨 

# 리스트에 어떤 상수를 더해서 재정의 가능 (이것 역시 그냥 리스트는 작동을 안함 위와 같은 케이스)
f += 10  
print(f)


# np.array를 쓰면 리스트 자체에 더하거나 행렬자체를 bool형으로 판단이 가능함 (대출 ㅈㄴ 편한 기능)
# 대신 리스트는 다른 자료형끼리 쓸 수 있지만 np.array행렬은 "같은" 자료형끼리만 쓸 수 있다.
# 저런 식으로 행렬계산을 할 수 있는데 @를 쓰게 되면 행렬의 내적이 됨  
v = np.array([1,2])
w = np.array([3,4])

print(v @ w) # 1 x 3 + 2 x 4 공학수학때 배운거니 기억이 나죠?

# 행렬의 재정의 reshape
hang = np.array([1,2,3,4]) # 1행 4열 
hang = np.reshape(hang , (2,2)) # 2행 2열  # (바꿀행렬 , (행 , 열)) # np.reshape

# 유용한 기능 <행렬합계>
x = np.array([1,2],[3,4])
print(np.sum(x))  # 행렬의 모든 요소가 더해서 나옴

# 여기서 column이나 row끼리 더할 수 있는데 column은 axis = 0 , row은 axis = 1 
# axis 는 sum() 안에 행렬과 같이 넣어주면 적용이 됨 


# 여기까지가 numpy요약

